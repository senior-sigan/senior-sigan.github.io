<!DOCTYPE html>
<html lang="">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Зачем учить машины?</title>
  <meta name="description" content="" />
  <!-- Yandex.Metrika counter -->
<meta name="yandex-verification" content="721d8d42ba7b40bb" />
<script type="text/javascript" >
    (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
    m[i].l=1*new Date();
    for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
    k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
    (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");
 
    ym(91297055, "init", {
         clickmap:true,
         trackLinks:true,
         accurateTrackBounce:true
    });
 </script>
 <noscript><div><img src="https://mc.yandex.ru/watch/91297055" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
 <!-- /Yandex.Metrika counter -->

  <link rel="stylesheet" href="/styles/index.css">
  <link rel="stylesheet" href="/styles/katex.min.css">
</head>

<body>
  <nav>
    <ul>
      <li><a class="internal-link" href="/"><b>Ilya&#39;s digital garden</b></a></li>
      <li><a class="internal-link" href="/talks">Talks</a></li>
      <li><a class="internal-link" href="/notes">Notes</a></li>
    </ul>
  </nav>

  <div class="wrapper">
    <main>
<article>
  <div>
    <h1>Зачем учить машины?</h1>
    <time datetime="2017-06-30">30 Jun 2017</time>
  </div>

  <div id="notes-entry-container">
    <content>
      <blockquote>
<p>Компьютеры становятся все умнее. Ученые утверждают, что скоро они смогут разговаривать с нами.<br>
Дейв Барри. (Под “они”, я подразумеваю компьютеры, а ученые, судя по всему, так и не научатся с нами разговаривать)</p>
</blockquote>
<p>Прежде чем мы с вами пустимся в пучину больших данных, статистики, теории обучения и , возможно, даже философии, давайте вспомним, как развивалась в принципе вычислительная техника и как мы пришли к тому, что мы сейчас имеем.</p>
<h2>Механические вычислительные машины</h2>
<blockquote>
<p>Поскольку это недостойно таких замечательных людей, подобно рабам, терять время на вычислительную работу, которую можно было бы доверить кому угодно при использовании машины</p>
</blockquote>
<p><img src="/assets/why-teach-machine/1_jPr_938zH7WkSWilHfcObA.jpeg" alt="Копия арифмометра Лейбница">
<em>Копия арифмометра Лейбница в <a href="https://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D0%BC%D0%B5%D1%86%D0%BA%D0%B8%D0%B9*%D0%BC%D1%83%D0%B7%D0%B5%D0%B9*(%D0%9C%D1%8E%D0%BD%D1%85%D0%B5%D0%BD)">Немецком музее</a>.</em></p>
<p>В 17-ом веке замечательные математики Паскаль, Лейбниц и, вероятно, многие другие, уставшие от постоянных монотонных арифметических вычислений, построили <a href="https://ru.wikipedia.org/wiki/%D0%90%D1%80%D0%B8%D1%84%D0%BC%D0%BE%D0%BC%D0%B5%D1%82%D1%80">механические арифмометры</a>, идею которых описал ни кто иной как Леонардо да Винчи еще в 15-ом веке. Всё было исполнено с использованием цилиндров, шестерёнок и прочих прелестных деталей.</p>
<p>Прогресс не стоял на месте. Жаккард придумал перфокарты для повторения каких-то шаблонов, а Бэббидж понял, что можно создать механическую программируемую перфокартами машину — аналитическую машину. Стартовал проект длиною во весь 19-ый век — создание разностной машины, использующей силу пара, в то время весьма популярного источника энергии. И как не вспомнить первую программистку Аду Байрон, которая помогала в создании этой чудо машины.</p>
<p><img src="/assets/why-teach-machine/1_0GiZx0RKwRFBPiER3ZpLcA.jpeg" alt="">
<em>Копия разностной машины в <a href="https://ru.wikipedia.org/wiki/%D0%9C%D1%83%D0%B7%D0%B5%D0%B9*%D0%BD%D0%B0%D1%83%D0%BA%D0%B8*(%D0%9B%D0%BE%D0%BD%D0%B4%D0%BE%D0%BD)">лондонском Музее науки</a></em></p>
<p>Примечательно то, что даже тогда, люди полагали, что им удастся создать мыслящую машину, в каком бы то ни было понимании процесса мышления. Единственное чего не хватало по их мнению — это шестерёнок, нужно просто добавить их чуть больше, чтобы производительность машины была достаточно высока.</p>
<blockquote>
<p>Машина будет иметь возможность мыслить, проявлять интеллектуальность, если будет достаточно производительной. XIX век.</p>
</blockquote>
<h2>Электромеханические и электронные машины</h2>
<p>В середине прошлого века стали создавать электромеханические вычислительные машины, использовали уже не шестеренки, а, например, лампы. Производительность по сравнению с аналитической машиной Бэббиджа стала просто невероятной, но интеллектуальности мы всё еще не наблюдали. А Тьюринг описал абстрактного вычислителя, тем самым формализовав процесс вычисления на компьютерах. Таким образом к 1960-м годам мы уже имели хорошо описанную и математически обоснованную область. Осталось только дело техники — улучшить производительность!</p>
<p>Если смотреть на развитие уже привычной нам электронной вычислительно техники, то можно условно определить следующие поколения:</p>
<ol>
<li>1940-ые — Электронные лампы</li>
<li>1950-ые — Транзисторы</li>
<li>1960-ые — Интегральные схемы</li>
<li>1970-ые — Микропроцессоры</li>
<li>1980-ые — Параллельные вычисления</li>
</ol>
<p>Сами по себе поколения нам не интересно разбирать, но интересно детальнее проанализировать концепции появившиеся в конце 70-ых годов, приведшие к так называемому пятому поколению.</p>
<h2><a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D1%8C%D1%8E%D1%82%D0%B5%D1%80%D1%8B_%D0%BF%D1%8F%D1%82%D0%BE%D0%B3%D0%BE_%D0%BF%D0%BE%D0%BA%D0%BE%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F">Пятое поколение</a> вычислительной техники</h2>
<p>Опьяненные успехами развития электроники, Японские ученые решили, что вот теперь, применив распараллеливание вычислений, запущенных на кластере компьютеров, и используя логические языки программирования типа <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%BB%D0%BE%D0%B3_(%D1%8F%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">Prolog</a> и языки обработки списков <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%B8%D1%81%D0%BF">Lisp</a>, они смогут получить искусственный интеллект, достигнув определенной вычислительной мощности. И, самое интересное, их не остановил на полпути тот факт, что уже вышли новые процессоры, обладающие куда большей мощности, чем они предполагали, а компьютеры так и не обладали интеллектом!</p>
<p>В итоге, спустя десять лет разработки, было потрачено около 500 миллионов долларов, но ИИ так и не появилось. Давайте подумаем, в чём же заключалась проблема? Неужели опять в недостатке мощностей?</p>
<blockquote>
<p>Машина будет иметь возможность мыслить, проявлять интеллектуальность, если будет распределенной. XX век.</p>
</blockquote>
<h2>Проблема программного ИИ</h2>
<p>Когда мы пишем программу, то мы фактически фиксируем языком программирования некоторую нашу абстрактную идею о некотором факте из природы. Люди создают абстракции, интерпретируя своё восприятие этого мира, то есть они базируются на каких-то знаниях, чувствах, морали, <a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BF%D0%B5%D1%87%D0%B0%D1%82%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5">импринтах</a> и так далее. Получается, абстракции, которые фиксируются строгими искусственными <em>логичными</em> языками программирования (которые, кстати, противоречивы с точки зрения формальной логики, так как базируются на <a href="https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BA%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D1%82%D0%B8%D0%B2%D0%BE%D1%80%D0%B5%D1%87%D0%B8%D1%8F">противоречивой</a> <a href="https://ru.wikipedia.org/wiki/%D0%9B%D0%BE%D0%B3%D0%B8%D0%BA%D0%B0_%D0%A5%D0%BE%D0%B0%D1%80%D0%B0">логике Хоара</a>, но это совсем другая история), не объективны хоть сколько-то. Разные люди скорее всего будут создавать разные абстракции, и это зависит не только от их мастерства программиста, аналитика, ученого.</p>
<p>![ ](/assets/why-teach-machine/1_kGSYV6 6R7OnXsFy7cTTvQ.jpg)</p>
<p><img src="/assets/why-teach-machine/1_WM8jBybO9wBSpWaAal0X4A.jpg" alt=" "></p>
<p>Найди несчетное множество отличий</p>
<p>А теперь представьте, что вас пригласили разрабатывать подсистему ИИ, способную отличать собаку от кошки. Вам показали две фотографии с кошкой и собакой. Представьте в голове, чем собака и кошка отличаются друг от друга. Теперь попробуйте мысленно формализовать эти идеи. Но, вдруг, вам показали две другие фотографии, которые вы не видели до этого никогда, и у вас, весьма вероятно, частично разрушатся предыдущие абстрактные идеи, на их смену придут новые, более точные, как вам кажется. Но, внезапно, отдел маркетинга понял, что еще надо научить отличать животных не только по фотографии, но и по звуку. Всё начинается сначала! И это еще не всё, настал момент разобраться в разных породах кошек и собак.</p>
<p>Из примера вы можете заметить, что мы с вам загнали себя в ловушку абстрактных воздушных замков. Если бы вы делали это задание в группе друзей, то, возможно, вы бы даже начали весьма горячий спор. Каждый новый пример частично ломает наши идеи, а путь исправления нам видится только в полном переписывании алгоритма.</p>
<blockquote>
<p>Путь исправления лежит через полное переписывание алгоритма. Знакомо?</p>
</blockquote>
<p>Почему это происходит? Почему не получается описать нечто раз и навсегда? Где же <a href="https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D1%80%D0%B5%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D1%8C">объективная реальность</a>, которую мы так хотим зафиксировать? А может такое быть, что мир слишком динамичен и разнообразен для наших закостенелых статических абстракций? Поэтому необходимо отыскать другие методы описания абстракций, которые не зависят от человеческого восприятия на столько, на сколько это вообще возможно. В этот момент мы можем подойти к идее машинного обучения.</p>
<p>Справедливости ради стоит отметить, что некоторый класс задач можно очень эффективно решать описывая эти статичные абстракции. Такие алгоритмы как правило очень эффективны, следовательно быстро работают. Например, поиск лиц на фотографии методом <a href="https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%B7%D0%BD%D0%B0%D0%BA%D0%B8_%D0%A5%D0%B0%D0%B0%D1%80%D0%B0">каскадов Хаара</a>, <a href="http://www.ee.columbia.edu/~dpwe/papers/Wang03-shazam.pdf">идентификация музыки</a>, фильтрация сигналов и так далее.</p>
<h2>Новый подход к построению ИИ</h2>
<p>Вместо того, чтобы человек сам описывал с помощью языка программирования некоторую свою субъективную абстракцию, предлагается использовать компьютер для этих целей. Тогда вместо программирования конечного алгоритма, мы будем создавать алгоритм, который ищет алгоритмы (<em>именно ищет, а не создаёт</em>). Здесь я предлагаю вам ознакомиться со статьей 2001 года “<a href="http://www.mathnet.ru/php/archive.phtml?wshow=paper&#x26;jrnid=sjim&#x26;paperid=115&#x26;option_lang=rus">Рефлексирующие программные системы</a>”. В ней авторы ставят вопрос почему программы до сих пор(2001 год) так и не стали интеллектуальными? Как наделить программы рефлексией, то есть способностью к самоулучшению?</p>
<blockquote>
<p>“Наиболее рациональный путь решения этой проблемы состоит в изучении того, как она решается живыми разумными системами в процессе их деятельности.”</p>
</blockquote>
<p>Для этого определяем некоторое начальное состояние системы и целевое состояние. Путь достижения целевого состояния не известен. Таким образом система должна отыскать каким-то образом этот путь, чтобы совершить переход между состояниями. Поиск может быть реализован как полный перебор чего-то. Если же цель сама по себе очень сложная и достижима разными путями, то мы, как и всегда, разбиваем задачу на подзадачи. Тем самым получаем иерархическую структуру(дерево) из целей, связанных между собой некоторыми путями для перехода. Вообразить это можно в виде пирамиды, в основании которой находятся цели решаемые алгоритмами некоторого первого уровня. Цели второго уровня решаются с помощью алгоритмов второго уровня, соответсвенно. Но что делает алгоритм с каждого следующего уровня этой пирамиды? Он выбирает алгоритм нижнего уровня для решения своей задачи.</p>
<blockquote>
<p>Когда мы пишем обычные программы, будь то вычисляющие сложные формулы или рисующие анимации на экране, мы создаем алгоритмы некоторого первого уровня.</p>
</blockquote>
<p>Можно сказать, что вся эта система из выбирающих друг друга алгоритмов, идущая к некоторой цели, обладает рефлексией и интеллектуальностью(если рассматривать когнитивную способность к обучению как интеллектуальную).</p>
<p>Вопрос в том, как создавать такие программы? Что они из себя представляют? Что такое поиск пути достижения цели или “подходящего” алгоритма? Что нас ждет на вершине пирамиды, если она существует? И где в этой пирамиде человек?</p>
<p>Как вы уже догадались, такие системы можно создавать с помощью машинного обучения.</p>
<h2>Машинное обучения</h2>
<p>Рассмотрим сразу пример простой задачи, с помощью которой можно легко объяснить суть маш. обуча.</p>
<p><img src="/assets/why-teach-machine/1_qOJHpFzTNnDPLCvEBkEe7w.jpg" alt=" "></p>
<p>Допустим у нас есть данные о размерах чашелистика и лепестка большого множества цветов ириса. По этим данным мы хотим научить машину отличать цветы различного вида друг от друга. Мы *предполагаем***,** что существует некоторая <strong>скрытая закономерность</strong> между видом цветка и его <strong>характеристиками</strong>. Процесс же обучения — это поиск зависимостей между наблюдаемыми характеристиками и скрытыми. В терминах информатики все вычислимые функции есть суть алгоритмы, таким образом мы с вами можем сказать, что машинное обучение как алгоритм и есть алгоритм 2-го уровня ищущий алгоритмы 1-го уровня.</p>
<p>Может показаться, что теперь мы можем взять любые данные и загрузить их в условный google cloud, чтобы решить нашу произвольную задачу. Но не случайно у нас есть целая пирамида алгоритмов. Оказывается, что определенный алгоритм машинного обучения, как алгоритм поиска, может искать закономерности не в полностью произвольных данных. Получается так, что мы, люди, должны выбирать эти алгоритмы 2-го уровня <strong>сами</strong> под определенные структуры данных.</p>
<blockquote>
<p>Некоторые боятся, что их заменят скриптом.</p>
<p>Продвинутые боятся, что их заменят машинным обучением.</p>
<p>Просветленные выбирают алгоритмы машинного обучение. (шутка)</p>
</blockquote>
<p>Именно из-за этой пирамидности нет Единого Алгоритма, людям всё ещё есть что делать и нельзя просто так спросить в чём смысл жизни и получить ответ, отличный от “42”.(на самом деле это проблема постановки правильного вопроса к бытию, которой, кстати, занимается философия)</p>
<h2>Проблемы машинного обучения</h2>
<p>Факт того, что нужно выбирать алгоритмы под задачу и данные порождает зоопарк разных алгоритмов маш.обуча. и классов задач(регрессия, классификация, кластеризация, …), возникает проблема предобработки данных и выбора подходящего алгоритма. Но как происходит этот выбор? Для этого оценивают метрики качества предсказания и пытаются интерпретировать результаты предсказания, чтобы понять почему алгоритм принял какое-то решение. Метрик качества тоже может быть много разных, в одном случае это может быть обычная точность(accuracy) предсказания, которая считает сколько раз алгоритм ошибся. Может быть <a href="https://ru.wikipedia.org/wiki/ROC-%D0%BA%D1%80%D0%B8%D0%B2%D0%B0%D1%8F">хитрая метрика</a>, которая учитывает <a href="https://ru.wikipedia.org/wiki/%D0%9E%D1%88%D0%B8%D0%B1%D0%BA%D0%B8_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%B8_%D0%B2%D1%82%D0%BE%D1%80%D0%BE%D0%B3%D0%BE_%D1%80%D0%BE%D0%B4%D0%B0">ошибки первого и второго рода.</a> А для задачи регресси, где предсказывают вещественные числа, можно считать величину отклонения от достоверного значения, или квадрат отклонения, или модуль… В общем вы уловили идею, есть нюансы.</p>
<p>Да, вы можете предположить, что можно написать алгоритм третьего уровня, который будет просто перебирать все метрики, алгоритмы_2 и как-то перемешивать данные, но стоит отметить, что это Полный Перебор по теоретически, неограниченному множеству вариантов. Нужны новые методы оптимизации, не те что применяются на втором уровне, а совсем другие. На сколько я понимаю их ещё нет. Но некоторые структуры, например, глубинные сети по сути своей скрывают внутри себя очень много слоев абстракций. На столько много, что нельзя сказать какой это “уровень” нашей воображаемой пирамиды. По всей видимости, поэтому глубокие сети сейчас действительно кажутся вот-вот-совсем интеллектуальными и, даже, обладающими “творчеством” или способностью создавать.</p>
<p>В любом случае, если вы ещё пишете алгоритмы первого уровня, то вас скоро автоматизируют. Не так давно нейросети научились <a href="https://nplus1.ru/news/2017/05/30/images">верстать по макетам</a>(sic!). Поэтому я зову вас на следующую ступеньку, где вы будете выбирать более абстрактные алгоритмы!</p>
<p>Для продолжение философствования, вы можете прочитать заметку <a href="/notes/2017-07-01-what-is-ai">Что такое искусственный интеллект
</a>.</p>
<p>Еще есть юмористические статьи <a href="/notes/2017-09-28-ml-pasta">ML паста</a> и <a href="/notes/2018-01-15-cipher-brain-questions">Вопросы оцифровки мозгов</a>.</p>
<p><img src="/assets/why-teach-machine/1_qQcpjDzsW4emueLJG6_Vfw.jpg" alt=" "></p>
    </content>
  </div>
</article></main>
  </div>
</body>

</html>