<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta property="og:site_name" content="Ilya&#39;s digital garden">

  <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgo=">

  <link rel="stylesheet" href="/app.css">

  
  <meta property="og:title" content="Android and Usb Story">
  <meta property="og:type" content="article">
  

  
  <meta property="article:published_time" content="">
  <meta property="article:author" content="/">
  

  <title>
    Android and Usb Story
  </title>

  
</head>

<body>
  <nav><ul>
    <li><a class="internal-link" href="/"><b>Ilya&#39;s digital garden</b></a></li>
    <li><a class="internal-link" href="about.html">About</a></li>
    <li><a class="internal-link" href="archive.html">Archive</a></li>
</ul></nav>
  <div class="wrapper">
    <main>

<article>
  <div>
    <h1>Android and Usb Story</h1>
    
    <time datetime="2017-01-29T12:00:00+06:00">
      Created on Jan 29, 2017
    </time>
    
  </div>

  <div id="notes-entry-container">
    <content>
      <p>Так как наметилась тенденция избавляться от аудиоразъема, то не остаётся в андроиде больше внешних интерфейсов кроме как USB. Надо изучить как с ним работать.</p>
<p>Раньше, во времена мамонтов, только некоторые андроид устройства позволяли подключать к ним по USB периферию. В этом случае говорят, что используется фича usb-host. Для этого покупали специальные OTG(On-The-Go)-usb переходники, которые одной стороной вставляются в android(mini/micro-usb), а с другой стороны обычный USB тип-A, в который можно вставлять другие USB устройства. Т.е. можно подключить флешку, видеокамеру, клавиатуру, мышку(sic!). Всё это конечно круто, но если вы хотите создать своё новое USB-slave устройство, которое можно будет подключать к host андроиду, то это не тривиальная задача совсем.</p>
<p>Но прогресс не стоял на месте и Android зарелизил новую фичу <a href="https://developer.android.com/adk/index.html">USB-accessory mode</a>, доступную для <em>всех</em> андроид устройств старше 4.4. Так вот, этот режим позволяет подключать андроид к другим устройствам в режиме accessory, т.е. теперь не андроид является хостом и питает другое устройство, а наоборот. Вместе с этим, google любезно подготовили библиотеки совместимые со многими arduino и usb-shield-ами. Таким образом, для разработчика железа, можно просто купить arduino, плату расширения usb-host и всё — можно паять своё устройство. А процесс обмена данными будет не простым, а очень простым — чистая передача бинарных данных в обе стороны. Не надо будет разбираться в том как именно работает usb, как правильно подключаться, так как это реализовано с одной стороны на андроиде и с другой в библиотеках для плат расширения. Очень удобно.</p>
<p>Но перейдем ближе к делу.</p>
<h2>Краткий обзор API</h2>
<p>Есть два способа получить usb-accessory в андроиде, первый способ — это явно запросить usb менеджер выдать вам список всех подключенных устройств и явно запросить доступ к одному из них, а второй способ — это подписаться на событие подключения устройства. Для этого вам нужно узнать <code>manufacturer</code>, <code>name</code>, <code>version</code> устройства и прописать это в файле <code>src/main/res/xml/accessory_filter.xml</code>. А в манифесте объявить какая активность будет реагировать на это событие. И конечно же в манифесте надо прописать, что вы используете feature usb-accessory.</p>
<pre class="highlight"><code class="language-xml">&lt;!-- accessory_filter.xml  --&gt;
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;resources&gt;
    &lt;usb-accessory manufacturer="SomeManufacturer" model="SUPER9000" version="1.0" /&gt;
&lt;/resources&gt;</code></pre>
<pre class="highlight"><code class="language-xml">&lt;!-- manifest.xml --&gt;
&lt;uses-feature
        android:name="android.hardware.usb.accessory"
        android:required="true" /&gt;

&lt;application&gt;
  ...
  &lt;activity&gt;
    ...
    &lt;meta-data
      android:name="android.hardware.usb.action.USB_ACCESSORY_ATTACHED"
      android:resource="@xml/accessory_filter" /&gt;
  &lt;/activity&gt;
&lt;/application&gt;</code></pre>
<p>Интересны факт. Можно не создавать <code>accessory_filter.xml</code>, а пользоваться только первым подходом. Сейчас андроид не требует явного определения устройств с которыми вы будете работать.</p>
<pre class="highlight"><code class="language-kotlin">// activity.kt

// вариант с явным запросом всех подключенных устройств.
val usbAccessory = context.usbManager.accessoryList?.firstOrNull()

// вариант с подписыванием на событие и его обработкой
override fun onCreate(savedInstanceState: Bundle?) {
  super.onCreate(savedInstanceState)

  log.info("USB device listener woke up")
  log.info("Got intent $intent")
  if (UsbManager.ACTION_USB_ACCESSORY_ATTACHED == intent.action) {
    val refreshDeviceIntent = Intent(UsbCanManager.ACTION_USB_DEVICE_ATTACHED)
    refreshDeviceIntent.putExtras(intent.extras)
    sendBroadcast(refreshDeviceIntent)
    log.info("Resend USB intent to service $refreshDeviceIntent")
  }

  finish()
}</code></pre>
<p>Но в любом случае, вы должны попросить у пользователя права на работу с данным устройством.</p>
<pre class="highlight"><code class="language-kotlin">context.usbManager.requestPermission(accessory, permissionIntent)</code></pre>
<p>И уже потом можно будет начать работу с usb:</p>
<pre class="highlight"><code class="language-kotlin">val parcelFd = usbManager.openAccessory(accessory) // открыть дескриптор
val inputStream = FileInputStream(pfd.fileDescriptor) // открыть потоки чтения и записи
val outputStream = FileOutputStream(pfd.fileDescriptor)</code></pre>
<p>И естественно, если есть событие на подключение устройства, то есть и обратное ему: <code>UsbManager.ACTION_USB_ACCESSORY_DETACHED</code>.</p>
<blockquote>
<p>История из жизни. Пришлось мне разрабатывать приложение для какой-то штуки, которая снимает показатели с датчиков машины и может быть подключена к андроиду по usb. По счастливой случайности я не знал ни формат бинарного протокола, ни имя-версию устройства. Вообще ничего. Даже эмулятора всей штуки не было, а тестировать все будет клиент, который находится +6 часов от меня. И вот тут-то в режиме реального времени через VPN я отлаживал процесс подключения через accessory. И как раз таки первый подход, где можно получить список устройств и спас меня. Так как те крохи спецификации железяки были неверными и подход с событием совсем не работал.</p>
</blockquote>
<p>Я рекомендую в приложении использовать сразу два подхода, на случай проблем с именем железяки, что приведет к неработоспособности подхода с фильтром. Стратегия работы будет тогда следующей — при запуске приложение проверяет подключен ли к нему девайс, если подключен, тогда запускаем вручную наши сервисы. Можно добавить кнопку, переподключиться (или swipe-to-refresh), чтобы можно было в любой момент повторить всю процедуру сначала.</p>
<blockquote>
<p><em>Напоминание!</em> Вся эта магия будет у вас происходить асинхронно и не однопоточно, поэтому подумайте о критических секциях и блокировках. Лучше конечно всё завернуть в один event-loop, чтобы проблем многопоточности у вас не было в принципе.</p>
</blockquote>
<h2>Тестирование</h2>
<p>Всё это конечно отлично, даже замечательно. Но чудесная библиотека от гугла, внезапно не заработала для моего arduino UNO и sparkfun shield. Что же делать? В этот момент логично предположить, что мы бы могли использовать наш десктоп с linux на борту выступать в роли хоста для нашего девайса. Я потратил некоторое время, чтобы наконец-то найти <a href="http://android.serverbox.ch/?p=262">пример</a> этой чудесной программы на чистом C, которая не требует тучи зависимостей и работает как надо.</p>
<p>Круто, подумал было я, и принялся отлаживать! Но как дебажить, если USB уже занят? Для этих целей есть функция проброса adb через вайфай. Это описано в <a href="https://developer.android.com/studio/command-line/adb.html#wireless">официальной документации</a>. Перечислю кратко шаги:</p>
<ol>
<li>Подключить android к компу по USB.</li>
<li>Прописать <code>adb tcpip 5555</code>.</li>
<li>Отсоединить девайс.</li>
<li>Найти ip адрес андроид устройства в его настройках.</li>
<li><code>adb connect &lt;DEVICE_IP_ADDRESS&gt;:5555</code></li>
<li>Profit!</li>
</ol>
<h2>Подводные камни? Какие подводные камни?</h2>
<p>Вы было подумали, что это идеально работает? Теперь вы сможете отлаживать работу usb?? Как бы не так! В документации совсем не говорят, что почему-то после подключения устройства по USB к другому устройству, даже не к КОМПУ с которого разрешили отладку, соединение по wifi-adb пропадает! ВСЕГДА. Нужно переподключаться.</p>
<blockquote>
<p>Если вы хотели отладить процесс подсоединения устройства, тот момент прилетания события от ОС о факте подключения usb-accessory, то ничего у вас никогда не получится. Андроид разорвет adb соединение. Вам придется опять писать <code>adb connect</code>. Но момент будет упущен!</p>
</blockquote>
<h2>Литература</h2>
<ul>
<li><a href="https://ru.wikipedia.org/wiki/USB">wiki: USB</a></li>
<li><a href="https://developer.android.com/adk/index.html">Accessory Development Kit guide</a></li>
<li><a href="https://developer.android.com/guide/topics/connectivity/usb/accessory.html">USB-accessory guide</a></li>
<li><a href="http://android.serverbox.ch/?p=262">Turn your Linux computer into a huge Android USB Accessory</a></li>
</ul>
    </content>

    <side style="font-size: 0.9em">
    
</side>

  </div>
</article>

<hr>

<p>Here are all the notes in this garden, along with their links, visualized as a graph. <i>(Use ctrl + scroll to zoom
    in-out)</i></p>

<script src="/scripts/libs/d3.min.js"></script>

<div id="graph-wrapper"></div>
<aside id="link-preview-block">
    

    <script src="/scripts/links_preview.js"></script>
</aside>

</main>
    <footer></footer>
  </div>
</body>

</html>